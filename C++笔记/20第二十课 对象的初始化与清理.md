# 对象的初始化与清理

### 构造函数和析构函数

一个对象或变量没有初始状态，对其使用后果未知

同样的使用完一个对象或变量，没有及时清理，也会造成一定的问题

**这两个函数由编译器自动调用**

### 构造函数

语法 ：**`类名(){}`**

**需在公共作用域public下才能访问的到**

构造函数**没有返回值**也**不写void**

**函数名称与类名相同**

构造函数**可以有参数**，因此可以发生重载

程序在调用对象的时候会自动调用构造，且只调用一次

```c++
class person{
public:
    func(){
        cout << "构造函数的调用";
    }
};
int main(){
    person lanson; //output: 构造函数的调用
}
```

（**实例化时自动调用构造函数**）

编译器也会自动创建，只不过是**空实现** `func(){}`

### 析构函数

语法： **`~类名(){}`**

**析构函数不可以有参数**

剩下的和构造函数相同

```c++
class person{
public:
    person(){
        cout << "构造函数的调用";
    }
    ~person(){
        cout << "析构函数的调用";
    }
};
int main(){
    person lanson; //output: 构造函数的调用  没有析构函数的调用
}
```

将**实例化直接写在main函数中**，只有构造**没有析构**

```c++
class person{
public:
    person(){
        cout << "构造函数的调用 ";
    }
    ~person(){
        cout << "析构函数的调用";
    }
};
void func(){
    person lanson;
}
int main(){
    func(); //output: 构造函数的调用 析构函数的调用
}
```

原因：如果把实例化**写在func函数里**，那么对象将**存放在栈区**，func执行完毕后自动释放，如果把实例化**写在main函数里**，那么将会在**main函数执行完后**执行析构函数